################################################################################
## gridmap
################################################################################
""" draws battle area, including grid for units """

""" NOTES:
    Make terrain altitude more consistant with surrounding terrain, allow for 
    degrees of variation based on ruggedness variable.
    
    Consider redoing with Grid_map.color, Grid_map.alt etc... as sub grids instead
    of as child class elements. less complicated and can make calls out to def 
    statements for updating different elements from a single for row for col pass. 
    Remove grid creation from main parent and create within each sub element.
"""
################################################################################
import images_lib
import sys
import pygame
#from collections import defaultdict
#from math import sqrt
#from random import choice, randint
from images_lib import (  GREEN, GRASS, BLACK, LT_GRAY )
import params
#import main_board

import unit_simp

################################################################################

class Grid_map(object):
    """ Rectangular grid map consisting of nrows X ncols squares.
        Squares can be blocked (by obstacles). """
    
    def __init__(self, screen):
        """ Create a new Grid_map with the given amount of rows/columns/info from params. 
        [x][y][info field]: x=x coord  y=y coord  
          layer: 0 = terrain color name (name and color name are same)
                 1 = object list (container)
                 2 = unit list (container)
                 3 = event list (container)
                 4 = passable (bool)
                 5 = altitude
                 6 = movement cost
                 7 = additional info
        """
        self.nrows = int(params.FIELD_RECT[2]/params.TILE_SIZE) # number of horizontal grid spaces in grid map
        self.ncols = int(params.FIELD_RECT[3]/params.TILE_SIZE) # number of vertical grid spaces in grid map
        self.fields = 8
        self.matrix = [[[0 for i in range(self.fields)] for i in range(self.ncols)] for i in range(self.nrows)]
        self.screen = screen
        self.selected = () # [0] = rows, [1] = cols NOTE: this is for dealing with mouse click selection
        self.fill_grid() # fills the grid's matrix with content
        self.last_clicked =(-1,-1)# coord for last tile clicked 
        
        
        self.pawn_group = unit_simp.Simp_unit_group() # adds group of units from unit_simp
        
        
    def fill_grid(self): # this is called by the init method
        """ fills initial matrix - it's already filled with a 0 """
        for row in range(0, self.nrows):
            for col in range(0, self.ncols):
                self.matrix[row][col][0] = self.fill_terrain()
                self.matrix[row][col][1] = self.fill_object()
                self.matrix[row][col][2] = self.fill_unit() # color - or sprite image of unit
                self.matrix[row][col][3] = self.fill_event()
                self.matrix[row][col][4] = self.fill_passable()               
                self.matrix[row][col][5] = self.fill_altitude()
                self.matrix[row][col][6] = self.fill_movecost()
                self.matrix[row][col][7] = self.fill_info()
        
    # BELOW are sub-methods called to by the fill_grid() method
    def fill_terrain(self):
        # fill with meadow terrain                                              - TODO: add variety 
        fill = GRASS #                                                          - TODO: replace with fill logic / default: GRASS
        #print("terrain added")
        return(fill)
    
    def fill_object(self):
        """ initially filled with a placeholder of 0 """ #                      - TODO: add list of objects to their corresponding grid
        fill = () #                                                             _ TODO: replace with object list / default: empty
        #print("object added")
        #return(fill)

    def fill_unit(self):
        """ initially filled with a placeholder of 0 """ #                      - TODO: add list of units to their corresponding grid
        fill = () #                                                             _ TODO: replace with unit list / default: empty
        #print("units added")
        #return(fill)
    
    def fill_event(self):
        # fill with meadow terrain                                              - TODO: add variety 
        fill = () #                                                             - TODO: replace with fill logic / default: empty
        #print("event added")
        return(fill)
    
    def fill_passable(self):
        # show if tile is passable (bool) / default: True (passable)
        fill = True
        #print("passable added")
        return(fill)    
    
    def fill_altitude(self):
        """ fill with altitude and adjust color """ #                           - TODO: add alt formula for geo shape of hills/valleys
        """ altitude = range from 0=6, with 3 being sea level """
        alt = 3 #                                                               - TODO: replace with altutude logic / default: 3
        #print("altitude added")
        return(alt)
    
    def fill_movecost(self):
        # show cost to enter tile / default: 1
        fill = 1 #                                                              - TODO: change cost based upon altitude and terrain type
        #print("movement cost added")
        return(fill) 
    
    def fill_info(self):
        # any special info regarding tile / default: none
        fill = "" #                                                             - TODO: develop section
        #print("info added")
        return(fill)  
    
    ## Grid Helper Methods #####################################################

    def update_grid(self): #                                                    - TODO - adapt to grid spaces with contents
        self.grid_unit_color_updater() # update unit positions
        for row in range(self.nrows):
            for col in range(self.ncols):
                if self.matrix[row][col][2] == 0: # print tile color if tile is empty
                    curser_color = self.matrix[row][col][0]
                else: # print unit color if tile has a unit in it
                    curser_color = self.matrix[row][col][2]
                pygame.draw.rect(  self.screen,
                                   curser_color,
                                   [(params.FIELD_RECT[0] + row * (params.TILE_SIZE + params.MARGIN)),
                                    (params.FIELD_RECT[1] + col * (params.TILE_SIZE + params.MARGIN)),
                                    params.TILE_SIZE,
                                    params.TILE_SIZE] )              
                        
    def grid_unit_color_updater(self):
        for row in range(self.nrows): # erase old data
            for col in range(self.ncols):
                self.matrix[row][col][2] = 0        
        for unit in self.pawn_group.group_list: # replace current unit locations
            #print("oh, here's a unit.")    
            #print("---------------------------- unit loc:", unit.loc)
            self.matrix[unit.loc[0]][unit.loc[1]][2] = unit.color
            #print("unit color:", unit.color)

    def coord_to_grid(self, pos):
        """ prints grid location based on pos(x,y) for test purposes of clicked location """
        self.selected = (  int((pos[0] - params.FIELD_RECT[0]) / (params.TILE_SIZE + params.MARGIN)),
                           int((pos[1] - params.FIELD_RECT[1]) / (params.TILE_SIZE + params.MARGIN)))
        #print(  "click pos:", pos, " grid pos:", self.selected)        
        return(self.selected)
    
    def print_grid(self):
        """ outputs text version of grid for testing """
        junk = False
        #print("I'm printing the screen now")
        
    def in_field(self, pos):
        """ verify if clicked pos is in grid area  - returns True/False """
        loc = self.coord_to_grid(pos)
        if loc[0] < 0 or loc[0] >= params.GRID_SIZE[0] or loc[1] < 0 or loc[1] >= params.GRID_SIZE[1]:
            #print("you missed the grid")
            return(False)
        else:
            return(True)
        
    def grid_clicked(self, pos):
        """ tells what grid was clicked on and reports for testing purposes 
            pos: the passed mouse coordinates variable passed through """
        #print("I'm checking to see what grid was clicked on.")
        #print(  "pos, matrix coord, fieldrect0, tilesize, margin:  ", 
                #pos, 
                #self.coord_to_grid(pos),
                #params.FIELD_RECT[0], 
                #params.TILE_SIZE, 
                #params.MARGIN )        
        if self.in_field(pos):
            if self.last_clicked != (-1,-1) and self.matrix[self.last_clicked[0]][self.last_clicked[1]][0] == GREEN: #reset previous tile clicked
                self.matrix[self.last_clicked[0]][self.last_clicked[1]][0] = GRASS 
            self.last_clicked = self.coord_to_grid(pos) # toggle target tile to new color
            self.matrix[self.last_clicked[0]][self.last_clicked[1]][0] = GREEN
            #print("last click was on:", self.last_clicked)
          
################################################################################
## TEST
################################################################################
if __name__ == "__main__":  
    #pygame.init()

    screen = pygame.display.set_mode((params.SCREEN_WIDTH, params.SCREEN_HEIGHT), 0, 32)
    pygame.display.set_caption("3-D Tile Array")
  
    done = False
    clock = pygame.time.Clock()
   
    gridmap = Grid_map(screen) #                                                * REQUIRED CALL TO CREATE GRIDMAP
 
    #for unit in gridmap.pawn_group.group_list:
        #print("oh, here's a unit.")    
        #print("---------------------------- unit loc:", unit.loc)
        
    #gridmap.grid_unit_color_updater()
 
    print("-- It all works pre-screen--")
    
    while done == False: #                                                       NOTE: This will be part of the regular game while loop
        for event in pygame.event.get(): # User did something
            if event.type == pygame.QUIT: # If user clicked close
                done = True # Flag that we are done so we exit this loop
            elif event.type == pygame.MOUSEBUTTONDOWN: # User clicks the mouse. Get the position
                pos = pygame.mouse.get_pos()
                gridmap.grid_clicked(pos)
                if gridmap.in_field(pos): # Check to see if click was in grid field for testing 
                    print("you hit the grid")
                elif not gridmap.in_field(pos):
                    print("you missed the grid")

        screen.fill(BLACK) # Set the screen background
        gridmap.update_grid() # Re-Image the grid
        clock.tick(20) # Limit to 20 frames per second
        pygame.display.flip() # Go ahead and update the screen with what we've drawn.
         
    print("final state of gridmap:")
    gridmap.print_grid()
   
    print()
    print("-- TEST DONE --")
    print()
    pygame.quit()
    sys.exit()   